# Virtual Datastream Generation: Condensed Version
**The following assumes everything is set up properly, as described in [initializing_new_daq.md](../initializing_new_daq.md).**

### 1. Install these packages
- `can-utils`
- `net-tools` 

Install with the command `sudo apt-get install [package name]`. As well, run the command `sudo modprobe vcan`. It should return nothing. If it doesn't, figure out how to install the `vcan` Linux module.

### 2. Make two virtual CAN sockets
Run `sudo ip link add type vcan` twice. This creates two virtual CAN sockets: `vcan0`, and `vcan1`.

### 3. Set Maximum Transmission Unit 
Run `sudo ip link set mtu 16 [interface name]` for the `vcan0` and `vcan1` interfaces. This sets the MTU to 16 bytes to replicate CAN classic's frame size.

### 4. Turn the sockets on
Run `sudo ip link set up [interface name]` for the `vcan0` and `vcan1` interfaces. This turns sets them to a state where clients can bind to them and send data.

### 5. Start generating random data over the sockets
Open two separate terminal sessions (in addition to your SSH terminal if you're doing remote access). On the first one, enter the command `cangen -I 103 -L 8 vcan0`. Nothing will happen, but your terminal is now being used by the cangen program, which is sending eight-byte-long packets (`-L 8`) with the CAN ID of `0x103` (`-I 103`). In the other terminal, enter the same command, but use an ID of `0x104` and an interface of `vcan1`. 

Make sure 0x103 and 0x104 are defined in one of your DBC files in the `./pythonAPI/dbc` folder. They should be defined in the sample DBC file `sensor_boards.dbc`, with device names of `Sensor_board_2_1` and `Sensor_board_2_2` respectively. Note: the IDs in the DBC are decimal numbers (`dec(0x103) = 259`).

### 6. Edit canInterface.py to use virtual CAN sockets instead of real ones
Comment out the definitions of `bus_one` and `bus_two` in `canInterface.py` where `can.interface.Bus` constructors have `bitrate` parameters, and uncomment the definitions of the buses where the `channel` parameters are `vcan0` and `vcan1`. 

**Make sure to swap the comments if you want to switch back to physical CAN sockets.** Save the file when finished editing. Make sure the edited file is the one present on the Raspberry Pi and will be the version that's built when you do a `docker compose up -d`.

### 7. Remove the wfrdaq-can_logger Docker image and rebuild
Make sure the Docker project is down (from the main project directory with `compose.yaml`, run `docker compose down -v`). Delete the can_logger Docker image with `docker rmi wfrdaq-can_logger`. Compose the project again to rebuild: `docker compose up -d`.

### 8. Open Grafana in a web browser and check if the sockets work
On a different computer connected to the same network as the Pi, navigate to `http://raspberrypi.local:3000`, login with grafana credentials, create a new dashboard, create a new visualization (click "add" button -> "visualization"), select the MQTT data source, and enter the topic `Sensor_board_2_1/Sensor1`. You might need to wait a few seconds and manually refresh the visualization with the "refresh dashboard" button in grafana a couple times before anything shows up. Change the time range to `now-20s` for best results:  

<img src="https://gist.github.com/assets/70295347/e14a552d-8e73-42f2-aacd-d5fa311cf75e" width="600">  

You should now see a graph with the random values being generated by `cangen` over the CAN sockets, which have been decoded by `canInterface.py` and are being broadcast over MQTT with the help of the `mqtt_broker` container:  

<img src="https://gist.github.com/assets/70295347/e33acbd7-a21c-4982-83d7-d8d7bd7156bf" width="800">  

Click "apply" and you should be returned to the grafana dashboard view. At this point, MQTT functionality has been verified.

### 9. Make another visualization with InfluxDB as a source  
Create another Grafana visualization like in step 8, but this time, select `influxdb` as the data source. 

In the "from" field, click "select measurement" and click "Sensor_board_2_1". 

In the "select" field, click "field(value)" and click "Sensor1". Click the "X" button beside "mean()", and then click the "+" button, and select "Selectors" -> "Last". 

Change the time range to "Last 5 minutes". You should see a set of data points that have been logged to InfluxDB with `canInterface.py`:

<img src="https://gist.github.com/assets/70295347/4297fa55-06ef-42c2-89c2-e74257c0fbde" width="800">  

This verifies InfluxDB is working properly. If the system is shutdown and restarted later on but the `containerization/volumes/influxdb_volume` has not been altered, this graph will show all data logged in previous logging periods as well, since data persists within the volume.


# Virtual CAN Datastream Generation
If you don't have the hardware, you can still generate a reliable datastream and build a DAQ testbed, right from the comfort of your own virtual machine. This uses virtual CAN interfaces provided by the SocketCAN Linux module to mimick a physical CAN controller, combined with tools from `can-utils` to generate the datastream.  

## Dependencies
- ``can-utils`` package (use command `sudo apt-get install can-utils`)
- ``net-tools`` package (use command `sudo apt-get install net-tools`)
- ``vcan`` linux module (use command `sudo modprobe vcan`, it should return nothing)

## Initialize Virtual CAN Network Interface 
First, a virtual CAN (vcan) interface must be initialized to emulate the exposure of the physical interface of a real CAN connection to the operating system. CAN interfaces, as used in the above section on drivers, are the real CAN connection equivalent of this. 

To do this, use this command: `sudo ip link add type vcan`, which uses the iproute2 Linux command-line utility to initialize a ``vcan`` interface, just as if you'd initialize any TCP or UDP interface. 

The default naming scheme for creation of this interface is `vcanX`, where X is the current number of other vcan's you have running on the machine.

You can **delete** this interface with the command `sudo ip link del vcan0`.

After the interface is created, it still needs to be turned on. To do this, we set it to an up state by using the command: `sudo ip link set up vcan0`. 

To view details about the interface, you can use the command `ifconfig vcan0`. If things go right, you will see something like this:

<img src="https://user-images.githubusercontent.com/70295347/234086585-22eea4eb-9471-43dc-84d5-902ed370da38.png" width="800">

## Maximum Transmission Unit (MTU)
The default MTU of `vcan0` is 72 bytes. Since we are using classic CAN and not CAN Flexible Data-rate (CAN FD), we only need an MTU of 16 bytes. 

To change this, we need to execute the command `sudo ip link set mtu 16 vcan0` while the interfaces are down. 

1. turn off the interface, 2. change MTU setting to 16, 3. turn the interface on again:  

<img src="https://user-images.githubusercontent.com/70295347/234093116-df71077a-3e69-456f-9da8-b466f780489e.png" width="800">

This doesn't change much, but I thought it worth noting in case CAN FD is considered/necessary/implemented in the future. Also, it helps you understand that the socket is similar to a faucet in that once it's on, it needs to be turned off first if you want to alter it.

## Generate the Datastream
Next, the datastream is generated using the `cangen` tool from the `can-utils` package.

To generate a stream of random data over the `vcan0` interface, you can use the command `cangen vcan0`. Nothing will happen in the terminal -- you will have the cursor blinking at you on a blank line, not able to type anything in the terminal -- but something is happening inside the machine.

To view the output of the datastream over the `vcan0` interface, allow the `cangen` process to operate in the current terminal tab/window, and open a new terminal tab/window.

In that new terminal, use the command `candump vcan0`. If everything is working properly, you'll see something like this:

<img src="https://user-images.githubusercontent.com/70295347/234086888-a2c09447-c1af-425d-b4a5-947ca0de0191.png" width="800">

The columns represent, respectively, the name of the interface, the ID of the device sending the message, the [size of the data in bytes], and the bytewise data itself. 

## Using the Virtual Datastream with DAQ Software
Now that we have a datastream running, we need to allow our DAQ software to use it, in lieu of the physical CAN interface it was designed to accomodate.

Firstly, the CAN protocol specified for use in `canInterface` takes only CAN frames originating from a device with the ID `0x036`. This detail is found in the `filters` object declaration in `canInterface`. 

**[Optional theory for further conceptual clarification, feel free to skip paragraph]** These filters will eventually route down the chain of abstraction into the Linux kernel via the SocketCAN API into the CAN device driver. If a real CAN controller is connected, the filter is applied directly to this electrical device to physically accept or reject CAN frames by using a minterm of the binary representation of the ID specified in this object. This is simulated in the software-only rendition of things also, since `vcan` mimicks a physical CAN controller, as mentioned earlier.

Anyway, this means we need to generate CAN data using only this fixed identifier in the CAN header. So, where before we had random identifiers somewhere in the valid CAN ID range, we will now only have a CAN identifier of `0x036`. This is done simply by running `cangen vcan0`, using the additional flag, `-I 036`. Change the size of the generated CANBUS frames with `cangen -L [size in bytes]` -- this is helpful for emulating devices which send with fixed-sized frames. CAN has a max data size of 64 bits (8 bytes). `cantools` has a hard time decoding CAN frames that are not 64 bits long, so just fix them to 8 bytes, even if you don't require that many. Example:

| CAN ID | CAN Data Size | `cangen` command       |
|--------|---------------|------------------------|
| 0x103  | 4 Bytes       | `cangen -L 4 -I 0x103` |
| 0x104  | 6 Bytes       | `cangen -L 6 -I 0x104` |
| 0x103  | 8 Bytes       | `cangen -L 8 -I 0x103` |
| 0x104  | 8 Bytes       | `cangen -L 8 -I 0x104` |

Next, the code CAN socket needs to use `vcan` instead of the regular CAN interface. Since `vcan` is provided with SocketCAN, all we do is change the `channel` parameter in the interface instantiation to `vcan0`. With virtual CAN, we don't need to worry about bitrate, so we remove this parameter. Filters stay, since they are CAN protocol-dependent, and we want this testbed to represent the real CAN protocol used in the car, as closely as possible. For your convenience, the `channel = vcan0` instantiation has been provided in `canInterface.py`, but commented out. Simply uncomment it, and comment the `channel = can` instantiation, and start the program as normal. Try to avoid committing to the main branch the `channel = vcan` version if you can. (That's mostly a message to me... :)

After that, install everything in `root/pythonAPI` with `pipenv install` as above, enter the shell via the command `pipenv shell`, and then run the program using `python3 canInterface.py`. Note that the program requires an installation of Python 3.9, and if you're on Ubuntu 22.02, you'll need to use add [deadsnakesPPA]() repository to your apt upstream to get it. **DO NOT USE** `update-alternatives`, because core Ubuntu utilities rely on the default Python version, and **you will break your OS** if you change it. Bind the Python 3.9 installation to the alias "python3.9" instead. [This is a helpful article,](https://web.archive.org/web/20230424193817/https://towardsdatascience.com/installing-multiple-alternative-versions-of-python-on-ubuntu-20-04-237be5177474?gi=b452d19fbee6) even though it's for an older version of Ubuntu. 

# Weird Behaviour?
I think things are working nominally now, but Mosquitto is still broken. I am going to try and fix this.

# Information Sources
- https://python-can.readthedocs.io/en/stable/interfaces/socketcan.html
- https://docs.kernel.org/networking/can.html 

# [Optional] Brief SocketCAN/OS Theory
Drivers allow the operating system's kernel (software) to interface with peripheral devices (hardware). 

Drivers are normally not accessible from the user space of the OS (the space we are currently programming in) because they are sensitive components of the machine, and require special treatment by the OS's core. Hence, they remain entirely under the kernel's control, where the kernel is layer below the user space. The kernel is effectively the brain of the operating system.

The question naturally arises: "how do we use peripheral devices from a user space program if we don't have control of the software that runs those devices?". The answer is *system calls* -- calls from the user space to the kernel asking for a specific functionality, with kernel functionality exposed via an API. 

More accurately, it is exposed via a set of APIs. Sockets are an example of a Linux network layer API from the user space to the kernel. The Linux network layer in the kernel is what actually takes care of most of the nitty gritty software-hardware communication. In SocketCAN, the driver controlling the physical CAN controller is in a sublayer of the Linux kernel, below the network layer. SocketCAN introduces support for the CAN protocol, but *in the network layer*, so there is now software control over the CAN controller with the Linux network layer, which makes CAN much easier to work with in the user space. 

You as the programmer don't need to worry about the complexity of writing code to handle queuing of CAN messages. You also can read from MANY can devices at a time, since each "socket" is basically a connection with a unique device, and you can have thousands of sockets going at a time, all of them orchestrated and controlled by the beautiful Linux kernel. This is a tremendous feat of systems programming, and saves us from having to dive into networking hell in the user space.      
